{"pages":[{"title":"About","text":"cp2019 計算機程式 課程倉儲: https://github.com/mdecourse/cp2019 內容管理: https://mdecourse.github.io/cp2019/ 課程投影片: https://mdecourse.github.io/cp2019/reveal 課程網誌: https://mdecourse.github.io/cp2019/blog","tags":"misc","url":"https://mdecourse.github.io/cp2019/blog/pages/about/"},{"title":"Leo Editor","text":"Leo Editor 是一個複雜的工具, 從它的 發展歷史 就不難發現, 1995 年發展的源頭來自 Donald Knuth's \"CWEB system of Structured documentation.\" 而 CWEB 建構的目的在於讓程式開發過程更容易讓人一目了然, 換言之 Leo Editor 利用大綱模式所建立的 .leo, 可以讓使用者存入與計算機程式相關的許多有用資訊, 使得一只程式系統在開發過程, 可以像寫文學作品一般, 透過大綱中的各類型條目, 述說與該程式相關的各種大小故事. 導入 Leo Editor 的瓶頸 但是由於 Leo Editor 從採用 Python 開發至今, 已經歷 14 年, 期間為了解決各種問題, 使用許多程式技術, 以目前最新的 6.1 版來說, 過去在 5.9 版所使用, 附在各檔案中的 @settings 設定卻不再適用, 而各資料區塊, 則已經支援利用滑鼠選擇移動, 但無論功能如何強化, 許多初學者一看到 Leo Editor , 通常無法在第一時間了解其功用, 所以本文將試著說明就 KMOLab 的程式開發或課程推動, 是如何使用 Leo Editor. CMSiMDE 的開發 CMSiMDE 是一套以機械設計工程使用為導向的網際內容管理系統, 開發用的 .leo 檔案位於 https://github.com/mdecourse/cmsimde/blob/master/cmsimde.leo, 其格式為 xml, 因此若多人協同使用 Leo Editor 開發程式, 每一位協同者都必須各自維護一個 .leo 檔案, 否則就可能被迫必須處理特定 .leo 檔案中的資料衝突, 而 xml 格式中的衝突合併, 絕對是分散式版次管理系統的使用者, 必須極力避免的難題之一. 採用 Leo Editor 進行程式開發的第一要訣, 除了各使用者必須自行維護一個 .leo 檔案外, 還必須了解 Leo Editor 中的大綱內容, 並非代表所開發程式的全部內容, 而是由各使用者選擇性利用大綱指令, 將所關心的資料, 以大綱格式從外部導入, 或者直接在各開發者的 .leo 檔案, 將資料存在大綱 body 中. Solvespace 的開發 Solvespace 是一套參數式 3D 零組件繪圖與設計軟體, 採用 C++ 編寫, 假如機械設計工程系大一的計算機程式課程能夠採用 Beginning C++ 與 Beginning C++ 17 作為 Textbooks, 讓學員利用 Msys2 編譯並修改維護 Solvespace 的原始碼, 應該是最佳的選擇. 而開發 Solvespace 的過程, 若能夠利用 Leo Editor 解析 .cpp 程式的功能, 透過下列 importer Leo Editor 內文程式 (即所謂的 Leo Script , 將 Solvespace 的原始碼自動分門別類, 轉為大鋼格式內容, 將有助於各程式模塊的解讀與修改. # 此一 Leo Script 放在 Leo Editor body 後, 按下 Ctrl + B 就可以執行 c.recursiveImport( # 從本目錄開始進行解讀 dir_ = r'./', # 利用 @clean 節點指令處理各受解讀的程式檔案 kind = '@clean', # 設為 True 表示各 @clean 節點指令前會再加上一個 @, 表示會將原始碼在 Leo Editor 轉存一份, 而不會複寫原始檔案 safe_at_file = True, # 宣告只解讀副檔名為 .cpp 的檔案 theTypes = ['.cpp'] ) 上述 C++ 程式開發流程也可套用到 Range3 開源 CAE 軟體程式的開發與應用. 機械設計與元件版次 設計經常牽涉重複流程的執行, 而且每次施行所牽涉的資料各有不同的版次, 這些軟硬體工具的版次差異, 對於參與協同設計的團隊也會產生不同程度的影響. 以目前 KMOLab 所採用的 kmol2020 可攜程式套件為例, Python 若升級至 3.8.1 以上, 其中的 CMSiMDE 就必須配合將 cgi.escape 換成 html.escape, 否則程式便無法執行, 而且先前從 Python2 留下的 \"is not\" 也被要求改為 \"!=\" 的語法. 至於 Leo Editor 本身的改版, 進入 6.1 之後, 先前的 @settings 似乎隨著滑鼠拖動視窗區塊的功能升級而無法使用, 且最新的版本在 Python 3.8.1 上仍有部分 bugs 尚未處理, 因此目前的 kmol2020 建議使用 5.9-b2 版本的 Leo Editor .","tags":"CP","url":"https://mdecourse.github.io/cp2019/blog/2019-Fall-Leo-Editor.html"},{"title":"Solvespace 與 Webots","text":"Webots 在 2018 年底開源後, 採用 Apache License Version 2.0 授權, 對於使用 MSYS2 與 Solvespace 的機械設計工程師而言. 加上開源 CAE Range3 以及 CAM OpenCAMLib , 在 Windows 10 環境中進行自由工程設計與分析套件的開發, 已經越來越完整. 目前的 Solvespace 可以建立適用於機構與應用分析用的零組件, 從 Solvespace 可以轉出 STL 與 WRL 格式的零組件, 將 STL 轉入 V-rep 之後, 可以透過 Group Divide 的功能, 轉出各自分離的定位零件, 之後再進行簡化, 使用上堪稱方便. 但是從 Solvespace 轉出的 WRL 格式組件, 當轉入 Webots 後, 目前則沒有工具可以輕易分割這些已經定位的零件, 因此就機構設計與分析的角度而言, 必須事先處理從 Solvespace 轉出的 WRL 格式組件, 或者進入 Solvespace 的原始碼, 修改成能夠像 Siemens NX 套件所提供的 WRL 轉出功能, 直接在一個 WRL 組件檔案, 分別切分出各不同零件的外型範圍. 以下的 Python 程式碼, 可以初步將 Solvespace 轉出的 STL 格式組件加以切割, 分別轉出個別零件的 STL 格式檔案. 就如同在 V-rep 中採用 Group Divide 的工具, 直接在場景環境中分離所需要的零件. 目前則希望可以將類似的組件分割原理, 用來處理從 Solvespace 轉出, 之後能轉入 Webots 進行系統模擬的 WRL 格式組立檔案. 首先是 stlSplitter.py 原始碼: #!/usr/bin/env python # STL splitter # splits a STL file containing separate objects # # copyright 2014 Francesco Santini <francesco.santini@gmail.com> # # based on https://github.com/cmpolis/convertSTL by Chris Polis # and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh # # Released under the MIT/X license import stlRW import sys from os import path ## functions # maybe insert a tolerance for floating points? def check_connection(tri1, tri2): for v1 in tri1[0:2]: for v2 in tri2[0:2]: if (v1[0] == v2[0] and v1[1] == v2[1] and v1[2] == v2[2]): return True return False if len(sys.argv) < 2: print(\"Usage: \" + sys.argv[0] + \" <file.stl>\") sys.exit(-1) fname = sys.argv[1] print(\"Reading...\") head,points,n,v1,v2,v3,isAscii = stlRW.stlRead(fname) print(\"Analyzing...\") faceTree = [] for triangleIndex in range(0, len(v1)): triangle = [ v1[triangleIndex], v2[triangleIndex], v3[triangleIndex], n[triangleIndex] ] connectedTo = [] for treeindex in range(0, len(faceTree)): for face in faceTree[treeindex]: if check_connection(face, triangle): connectedTo.append(treeindex) # the triangle is connected to at least one triangle of the current treeIndex break if len(connectedTo) == 0: # this is a triangle from a new set #print \"new set\" faceTree.append([]) faceTree[len(faceTree)-1].append(triangle) elif len(connectedTo) == 1: #print \"existing set\" # the triangle is connected to one set faceTree[connectedTo[0]].append(triangle) else: #print \"connecting triangle\" #this triangle connects two branches of the tree: collapse the branches faceTree[connectedTo[0]].append(triangle) for i in range(len(connectedTo)-1, 0, -1): faceTree[connectedTo[0]].extend(faceTree.pop(connectedTo[i])) print(\"Number of separate objects: \", len(faceTree)) print(\"Writing files\") origFile, origExt = path.splitext(fname) for i in range(0, len(faceTree)): newFile = origFile + \"-\" + str(i+1) + origExt print(\"Writing \", newFile) n = [field[2] for field in faceTree[i]] v1 = [field[0] for field in faceTree[i]] v2 = [field[1] for field in faceTree[i]] v3 = [field[2] for field in faceTree[i]] stlRW.stlWrite(newFile, n, v1, v2, v3) 接著是 stlRW.py 原始碼: # STL reader-writer # # copyright 2014 Francesco Santini <francesco.santini@gmail.com> # # based on https://github.com/cmpolis/convertSTL by Chris Polis # and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh # # Released under the MIT/X license import numpy as np from struct import unpack, pack def stlReadBinary(fname): fp = open(fname, 'rb') Header = fp.read(80) nn = fp.read(4) Numtri = unpack('i', nn)[0] #print nn record_dtype = np.dtype([ ('normals', np.float32,(3,)), ('Vertex1', np.float32,(3,)), ('Vertex2', np.float32,(3,)), ('Vertex3', np.float32,(3,)) , ('atttr', '<i2',(1,) ) ]) data = np.fromfile(fp , dtype = record_dtype , count =Numtri) fp.close() Normals = data['normals'] Vertex1= data['Vertex1'] Vertex2= data['Vertex2'] Vertex3= data['Vertex3'] p = np.append(Vertex1,Vertex2,axis=0) p = np.append(p,Vertex3,axis=0) #list(v1) Points =np.array(list(set(tuple(p1) for p1 in p))) return Header,Points,Normals,Vertex1,Vertex2,Vertex3,False def stlReadAscii(fname): fp = open(fname, 'r') Normals = [] Vertex1 = [] Vertex2 = [] Vertex3 = [] Points = [] while True: line = fp.readline() if not line: break if line.find(\"solid\") > -1 or line.find(\"endfacet\") > -1: continue if line.find(\"facet normal\") > -1: normline = line[line.find(\"facet normal\")+len(\"facet normal\"):] normal = np.array([float(val.strip()) for val in normline.split()]) Normals.append(normal) vertices = [] fp.readline() # outer loop # read vertices after normal for vIndex in range(0,3): vLine = fp.readline() vLine = vLine[vLine.find(\"vertex\")+len(\"vertex\"):] vertices.append(np.array([float(val.strip()) for val in vLine.split()])) Vertex1.append(vertices[0]) Vertex2.append(vertices[1]) Vertex3.append(vertices[2]) Points.extend(vertices) fp.readline() # endloop return \"\", Points, Normals, Vertex1, Vertex2, Vertex3,True def stlRead(fname): fp = open(fname, \"r\") try: if fp.readline().find(\"solid\") > -1: fp.close() return stlReadAscii(fname) else: fp.close() return stlReadBinary(fname) except: return stlReadBinary(fname) def stlWriteBinary(fname, normals, v1, v2, v3): with open(fname, \"wb\") as fout: # write 80 bytes header for i in range(0, 80): fout.write(pack(\"<c\", b\" \")) fout.write(pack(\"<I\", len(normals))) # number of triangles for i in range(0, len(normals)): fout.write(pack(\"<fff\", *normals[i])) fout.write(pack(\"<fff\", *v1[i])) fout.write(pack(\"<fff\", *v2[i])) fout.write(pack(\"<fff\", *v3[i])) fout.write(pack(\"<H\", 0)) # attribute def writeVector(fd, vec): for v in vec: fd.write(\"{:.7e}\".format(v)) fd.write(\" \") def stlWriteAscii(fname, normals, v1, v2, v3): with open(fname, \"w\") as fout: fout.write(\"solid \\n\") for i in range(0, len(normals)): fout.write(\" facet normal \") writeVector(fout, normals[i]) fout.write(\"\\n\") fout.write(\" outer loop\\n\") fout.write(\" vertex \") writeVector(fout, v1[i]) fout.write(\"\\n\") fout.write(\" vertex \") writeVector(fout, v2[i]) fout.write(\"\\n\") fout.write(\" vertex \") writeVector(fout, v3[i]) fout.write(\"\\n\") fout.write(\" endloop\\n\") fout.write(\" endfacet\\n\") def stlWrite(fname, normals, v1, v2, v3, isAscii=False): if isAscii: stlWriteAscii(fname, normals, v1, v2, v3) else: stlWriteBinary(fname, normals, v1, v2, v3) # test if __name__ == \"__main__\": import sys fname = sys.argv[1] h,p,n,v1,v2,v3,isAscii = stlRead(fname) print(len(n)) print(v1[0]) stlWriteBinary(\"binary.stl\", n, v1, v2, v3); stlWriteAscii(\"ascii.stl\", n, v1, v2, v3);","tags":"CP","url":"https://mdecourse.github.io/cp2019/blog/2019-Fall-Solvespace_and_Webots.html"},{"title":"2019 Fall CP 課程","text":"2019 Fall 一開始, 1903 版的 Windows 10 就大舉更新, 除了逐步去掉先前許多舊版的設定視窗, 也將系統的指令搜尋與 App 應用程式進行綁定. 許多採用可攜設定的程式執行流程, 隨著更新進程的推展, 必須因應修改才可以正常運作. 為何要使用可攜系統 自從 1995 年 Windows 95 與 Solidworks 95 在個人電腦中推出, 至今二十幾年, 幾乎所有與機械設計相關的單機套件的操作系統都在 Windows 上, 但是一旦需要建構所謂的 client-server 或雲端機械設計運算系統, 以 Ubuntu 為主的 Linux 伺服器顯然在成本與效益上, 擁有許多優勢. 因此長遠來看, 任何在 Windows 上操作的計算機運算流程, 都必須設法能夠在 Windows 與 Linux 上運作. 在 Windows 10 環境中使用可攜系統的原因, 主要是讓計算機程式課程中所使用的工具, 都可以放在 USB 3.0 規格以上的隨身碟或隨身硬碟上運作, 而第二個原因則是希望這些工具都能相容於 Linux 系統. Windows 10 更新所造成的問題 電腦輔助設計室中的第三磁區, 在完全沒有還原保護的情況下, 每一台電腦每次開機都會執行 Windows 10 的更新檢查, 然後依照更新期程的排定, 逐步更新. 因此, 從實際面來看, 每一台電腦的設定與內容並非完全相同. 使用者在開機後, 就必須根據電腦的現況進行因應. 而電腦操作系統更新造成的問題在於: 各電腦的實際現況與下載可攜系統當時製作環境不同, 因此部分設定必須配合修改後, 才可正常運作. 系統 path 搜尋路徑的修改 Windows 10 1903 版次在 Fall 開學後, 將 Python 執行路徑的搜尋納入系統 path 後, 假如所使用的 Windows 10 並未安裝 Python 解譯套件, 以系統內定 path 搜尋後, 會自動將使用者導引到 Python App 的安裝畫面. 這樣的改變, 將會對原先可攜程式系統造成兩種影響, 第一的影響是: start.bat 中以系統 path 設為第一優先下, 使用者在命令列中輸入 python 解譯器指令時, Windows 10 就會將使用者帶到要求 Python App 安裝的畫面. 因應修改的方法, 就是將 start.bat 中操作系統 path 優先權去除, 也就是 set path=%path%;... 中的 %path% 放到最後順序, 或者乾脆刪除. 第二項影響則是對 SciTE中 Python 的程式執行. 因為 2019 Fall 開始隨身程式系統製作時 path 可綁訂至隨身系統中的 Python 3.7.3, 因此 SciTE 中有關 .py 程式執行設定, 直接設為 path 中, 以 pythonw.exe 解譯 .py 程式, 一旦 path 無法指到隨身系統中的 python 解譯系統, SciTE 中的 .py 程式執行, 就必須明確指定 Python 3.7.3 所在的指令路徑. 也就是帶出 Options -> python.properties 設定檔案, 然後進行修改: if PLAT_WIN command.go.*.py=Y:\\cad\\201906_fall\\data\\py373\\pythonw -u \"$(FileNameExt)\" command.go.subsystem.*.py=1 command.go.*.pyw=pythonw -u \"$(FileNameExt)\" command.go.subsystem.*.pyw=1 command.build.SConscript=scons.bat --up . command.build.SConstruct=scons.bat . python 執行路徑的修改 除了採用明碼進行設定的 python.properties 必須配合修改外, 以二位元碼設定的 py373/Scripts/pelican.exe 也必須利用 hxd 進行 python 執行路徑字串置換修改. 安裝 python 新增模組 當使用者在執行 python 解譯時, 若碰到缺少特定模組時, 可以利用 python -m pip install flask_cors 進行安裝. Pelican 設定修改 theme/attila/templates/base.html 中必須進行下列修改: (function(){ var corecss = document.createElement('link'); var themecss = document.createElement('link'); var corecssurl = \"./../cmsimde/static/syntaxhighlighter/css/shCore.css\"; if ( corecss.setAttribute ) { corecss.setAttribute( \"rel\", \"stylesheet\" ); corecss.setAttribute( \"type\", \"text/css\" ); corecss.setAttribute( \"href\", corecssurl ); } else { corecss.rel = \"stylesheet\"; corecss.href = corecssurl; } document.getElementsByTagName(\"head\")[0].insertBefore( corecss, document.getElementById(\"syntaxhighlighteranchor\") ); var themecssurl = \"./../cmsimde/static/syntaxhighlighter/css/shThemeDefault.css?ver=3.0.9b\"; if ( themecss.setAttribute ) { themecss.setAttribute( \"rel\", \"stylesheet\" ); themecss.setAttribute( \"type\", \"text/css\" ); themecss.setAttribute( \"href\", themecssurl ); } else { themecss.rel = \"stylesheet\"; themecss.href = themecssurl; } //document.getElementById(\"syntaxhighlighteranchor\").appendChild(themecss); document.getElementsByTagName(\"head\")[0].insertBefore( themecss, document.getElementById(\"syntaxhighlighteranchor\") ); })(); SyntaxHighlighter.config.strings.expandSource = '+ expand source'; SyntaxHighlighter.config.strings.help = '?'; SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\\n\\n'; SyntaxHighlighter.config.strings.noBrush = 'Can\\'t find brush for: '; SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\\'t configured for html-script option: '; SyntaxHighlighter.defaults['pad-line-numbers'] = false; SyntaxHighlighter.defaults['toolbar'] = false; SyntaxHighlighter.all();","tags":"Misc","url":"https://mdecourse.github.io/cp2019/blog/2019-Fall-Win10-1903.html"}]}